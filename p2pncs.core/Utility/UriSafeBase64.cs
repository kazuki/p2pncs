/*
 * Copyright (C) 2009-2010 Kazuki Oikawa
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

using System;

namespace p2pncs.Utility
{
	public static class UriSafeBase64
	{
		const string EncodeTable = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
		static readonly byte[] DecodeTable = new byte[] {
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3e, 0x00, 0x00, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
			0x3a, 0x3b, 0x3c, 0x3d, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06,
			0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,
			0x19, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x00, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,
			0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
			0x00, 0x00, 0x00, 0x00
		};
		const char PADDING = '.';

		public static string Encode (byte[] inArray)
		{
			return Encode (inArray, 0, inArray.Length);
		}

		public static string Encode (byte[] inArray, int offset, int length)
		{
			if (length == 0)
				return string.Empty;

			string table = EncodeTable;
			int blocks = length / 3;
			int mod = length % 3;
			char[] output = new char[((length + 2) / 3) * 4];
			int io = offset, oo = 0;
			for (int i = 0; i < blocks; i ++) {
				byte b1 = inArray[io];
				byte b2 = inArray[io + 1];
				byte b3 = inArray[io + 2];
				output[oo] = table[b1 >> 2];
				output[oo + 1] = table[((b1 << 4) & 0x30) | (b2 >> 4)];
				output[oo + 2] = table[((b2 << 2) & 0x3c) | (b3 >> 6)];
				output[oo + 3] = table[b3 & 0x3f];
				io += 3;
				oo += 4;
			}
			switch (mod) {
				case 1:
					byte b1 = inArray[io];
					output[oo] = table[b1 >> 2];
					output[oo + 1] = table[(b1 << 4) & 0x30];
					output[oo + 2] = PADDING;
					output[oo + 3] = PADDING;
					break;
				case 2:
					byte c1 = inArray[io];
					byte c2 = inArray[io + 1];
					output[oo] = table[c1 >> 2];
					output[oo + 1] = table[((c1 << 4) & 0x30) | (c2 >> 4)];
					output[oo + 2] = table[(c2 << 2) & 0x3c];
					output[oo + 3] = PADDING;
					break;
			}
			return new string (output);
		}

		public static byte[] Decode (string str)
		{
			if (str == null)
				throw new ArgumentNullException ();
			if (str.Length == 0)
				return new byte[0];
			if (str.Length % 4 != 0)
				throw new FormatException ();
			int tail = 0;
			if (str[str.Length - 1] == PADDING)
				tail = (str[str.Length - 2] == PADDING ? 2 : 1);
			byte[] table = DecodeTable;
			byte[] output = new byte[(str.Length - 4) / 4 * 3 + (3 - tail)];
			int blocks = (str.Length / 4) - (tail == 0 ? 0 : 1);
			int io = 0, oo = 0;
			for (int i = 0; i < blocks; i ++) {
				byte b1 = table[(byte)str[io]];
				byte b2 = table[(byte)str[io + 1]];
				byte b3 = table[(byte)str[io + 2]];
				byte b4 = table[(byte)str[io + 3]];
				output[oo] = (byte)((b1 << 2) | (b2 >> 4));
				output[oo + 1] = (byte)((b2 << 4) | (b3 >> 2));
				output[oo + 2] = (byte)((b3 << 6) | b4);
				io += 4;
				oo += 3;
			}
			if (tail != 0) {
				byte b1 = table[(byte)str[io]];
				byte b2 = table[(byte)str[io + 1]];
				output[oo] = (byte)((b1 << 2) | (b2 >> 4));
				if (tail == 1) {
					byte b3 = table[(byte)str[io + 2]];
					output[oo + 1] = (byte)((b2 << 4) | (b3 >> 2));
				}
			}
			return output;
		}
	}
}
